{"./":{"url":"./","title":"简介","keywords":"","body":" ✋ Hey bro let's make the algorithm to understand easily --> const gitalk = new Gitalk({ clientID: '7b81f4981d72316f2823', clientSecret: '1cbc5a2846555c27b6f22f47ee47f5715aec87e3', repo: 'leetcode-googtech', owner: 'YUbuntu0109', admin: ['YUbuntu0109'], id: location.pathname, distractionFreeMode: false }); gitalk.render('gitalk-container'); Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/":{"url":"算法入门必须知识点/","title":"必学知识点","keywords":"","body":" 📖 数据结构和算法必知必会的50个代码实现( C，Python，Java ) Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/":{"url":"算法入门必须知识点/Python语言实现/","title":"Python 语言实现","keywords":"","body":" 📖 数据结构和算法必知必会的50个代码实现( Python ) Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/栈/栈.html":{"url":"算法入门必须知识点/Python语言实现/栈/栈.html","title":"栈","keywords":"","body":" 栈的代码实现及应用 ''' @Author: Goog Tech @Date: 2020-07-10 20:23:37 @Description: Stack @FilePath: \\data-structures-and-algorithms\\Python\\stack\\Stack.py ''' ''' @description: 定义一个栈 ''' class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self,item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) ''' @description: 使用栈来匹配符号 ''' class MatchBrace: ''' @description: 匹配括号 @param {string} @return: bool ''' def parChecker(self,symbolString): stack = Stack() balanced = True index = 0 while index )]}\" if opens.index(top) != closers.index(symbol): balanced = False index = index + 1 if balanced and stack.isEmpty(): return True else: return False ''' @description: 测试 ''' mb = MatchBrace() print(mb.parChecker(\"(((((((((())))))))))\")) # True print(mb.parChecker(\"(((((((((()))))))))\")) # False: 少个 \")\" print(mb.parCheckerPlus(\"(({{[[>]]}}))\")) # True print(mb.parCheckerPlus(\"(({{[[>]]}}))\")) # False: 少个 \">\" Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/链表/":{"url":"算法入门必须知识点/Python语言实现/链表/","title":"链表","keywords":"","body":" 🐍 链表 Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/链表/无序链表/无序链表.html":{"url":"算法入门必须知识点/Python语言实现/链表/无序链表/无序链表.html","title":"无序链表","keywords":"","body":" 无序链表的代码实现 ''' @Author: Goog Tech @Date: 2020-07-13 17:51:29 @Description: 无序列表 @FilePath: /leetcode-googtech/data-structures-and-algorithms/Python/list/unordered list/UnorderedList.py ''' ''' @description: 声明链表 ''' class Node: def __init__(self,initdata): self.data = initdata self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self,newdata): self.data = newdata def setNext(self,newnext): self.next = newnext ''' @description: 操作链表 ''' class UnorderedList: ''' 初始化链表 ''' def __init__(self): self.head = None ''' 判断链表是否为空 ''' def isEmpty(self): return self.head == None ''' 向链表中插入新节点 ''' def add(self,item): temp = Node(item) temp.setNext(self.head) self.head = temp ''' 获取链表的长度 ''' def getLength(self): current = self.head count = 0 while current != None: count = count + 1 current = current.getNext() return count ''' 搜索链表中指定数值节点 ''' def search(self,item): current = self.head found = False while current != None and not found: try: if current.getData() == item: found = True else: current = current.getNext() except AttributeError: print('error: the node of head is null') exit(1) return found ''' 移除链表中指定数值节点 ''' def remove(self,item): current = self.head previous = None found = False while not found: if current.getData() == item: found = True else: previous = current current = current.getNext() if previous == None: self.head = current.getNext() else: previous.setNext(current.getNext) return found ''' @description: 测试 ''' ud = UnorderedList() ud.add(1) ud.add(2) ud.add(3) print('链表的长度: %s'%ud.getLength()) print('链表是否为空: %s'%ud.isEmpty()) print('是否成功查找到指定元素: %s'%ud.search(1)) print('是否成功移除指定元素: %s'%ud.remove(2)) Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/搜索/":{"url":"算法入门必须知识点/Python语言实现/搜索/","title":"搜索","keywords":"","body":" 🐍 搜索 Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/搜索/二分搜索/二分搜索.html":{"url":"算法入门必须知识点/Python语言实现/搜索/二分搜索/二分搜索.html","title":"二分搜索","keywords":"","body":" 二分搜索的代码实现 ''' @Author: Goog Tech @Date: 2020-07-12 22:05:11 @Description: binary search @FilePath: \\leetcode-googtech\\docs\\算法入门必须知识点\\Python语言实现\\搜索\\二分搜索\\BinarySearch.py ''' class BinarySearch: ''' @description: 二分搜索 @param {alist,item} @return: bool ''' def orderedList(self,alist,item): first = 0 last = len(alist) - 1 found = False while first Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/搜索/顺序搜索/顺序搜索.html":{"url":"算法入门必须知识点/Python语言实现/搜索/顺序搜索/顺序搜索.html","title":"顺序搜索","keywords":"","body":" 顺序搜索的代码实现 ''' @Author: Goog Tech @Date: 2020-07-12 21:05:54 @Description: sequential search @FilePath: \\leetcode-googtech\\docs\\算法入门必须知识点\\Python语言实现\\搜索\\顺序搜索\\SequentialSearch.py ''' class SequentialSearch: ''' @description: 无序列表的顺序搜索 @param {alist,item} @return: bool ''' def unorderedList(self,alist, item): pos = 0; found = False while pos Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/排序/":{"url":"算法入门必须知识点/Python语言实现/排序/","title":"排序","keywords":"","body":" 🐍 排序 Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/排序/冒泡排序/冒泡排序.html":{"url":"算法入门必须知识点/Python语言实现/排序/冒泡排序/冒泡排序.html","title":"冒泡排序","keywords":"","body":" 冒泡排序的代码实现 ''' @Author: Goog Tech @Date: 2020-07-13 14:54:48 @Description: bubble sort @FilePath: algorithms.show\\leetcode-googtech\\data-structures-and-algorithms\\Python\\sort\\bubble sort\\BubbleSort.py ''' class BubbleSort: ''' @description: 冒泡排序 @param {alist} @return: ''' def bubbleSort(self,alist): for passnum in range(len(alist)-1,0,-1): # range(start, stop[, step]) for i in range(passnum): if alist[i] > alist[i+1]: temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp print(alist) ''' @description: 短冒泡排序，可判断出是否为有序列表 @param {type} @return: ''' def shortBubbleSort(self,alist): exchanges = True passnum = len(alist) - 1 while passnum > 0 and exchanges: exchanges = False for i in range(passnum): if alist[i] > alist[i+1]: exchanges = True temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp passnum = passnum - 1 print(alist) b = BubbleSort() # [1, 2, 3, 4, 5, 6] b.bubbleSort([6,5,4,3,2,1]) b.shortBubbleSort([6,5,4,3,2,1]) Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/排序/选择排序/选择排序.html":{"url":"算法入门必须知识点/Python语言实现/排序/选择排序/选择排序.html","title":"选择排序","keywords":"","body":" 选择排序的代码实现 ''' @Author: Goog Tech @Date: 2020-07-13 15:35:00 @Description: selection sort @FilePath: algorithm.show\\leetcode-googtech\\data-structures-and-algorithms\\Python\\sort\\selection sort\\SelectSort.py ''' class SelectionSort: ''' @description: 选择排序 @param {alist} @return: ''' def selectionSort(self,alist): for fillslot in range(len(alist)-1,0,-1): # range(start, stop[, step]) positionOfMax = 0 # 寻找最大值 for location in range(1,fillslot+1): if alist[location] > alist[positionOfMax]: positionOfMax = location # 交互数据 temp = alist[fillslot] alist[fillslot] = alist[positionOfMax] alist[positionOfMax] = temp print(alist) s = SelectionSort() s.selectionSort([6,5,4,3,2,1]) # [1, 2, 3, 4, 5, 6] Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Python语言实现/排序/插入排序/插入排序.html":{"url":"算法入门必须知识点/Python语言实现/排序/插入排序/插入排序.html","title":"插入排序","keywords":"","body":" 插入排序的代码实现 ''' @Author: Goog Tech @Date: 2020-07-13 16:05:46 @Description: insertion sort @FilePath: alogrithm.show\\leetcode-googtech\\data-structures-and-algorithms\\Python\\sort\\InsertionSort\\InsertionSort.py ''' class InsertionSort: ''' @description: 插入排序 @param {alist} @return: ''' def insertionSort(self,alist): for index in range(1,len(alist)): currentValue = alist[index] position = index while position > 0 and alist[position-1] > currentValue: alist[position] = alist[position-1] position = position - 1 alist[position] = currentValue print(alist) i = InsertionSort() i.insertionSort([6,5,4,3,2,1]) # [1, 2, 3, 4, 5, 6] Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Java语言实现/":{"url":"算法入门必须知识点/Java语言实现/","title":"Java 语言实现","keywords":"","body":" 📖 数据结构和算法必知必会的50个代码实现( Java ) Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Java语言实现/链表/":{"url":"算法入门必须知识点/Java语言实现/链表/","title":"链表","keywords":"","body":" 📖 链表 Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"算法入门必须知识点/Java语言实现/链表/单向链表/单向链表.html":{"url":"算法入门必须知识点/Java语言实现/链表/单向链表/单向链表.html","title":"单向链表","keywords":"","body":" 单向链表的代码实现 // 声明单向链表 class SinglyListNode { private E data; private SinglyListNode next; public E getData() { return data; } public void setData(E data) { this.data = data; } public SinglyListNode getNext() { return next; } public void setNext(SinglyListNode next) { this.next = next; } } // 操作单向链表 class SinglyLinkedList { SinglyListNode headNode; // 初始化单向链表 public void createLinkedList() { headNode = new SinglyListNode(); // headNode.setData(0); // 单向链表的头节点默认值为零 } // 获取单向链表的头节点 public T getHeaderNode() { return headNode.getData(); } // 获取单向链表的长度 public int getListLength(/* ListNode headNode */) { int length = 0; SinglyListNode currentNode = headNode; while (currentNode != null) { currentNode = currentNode.getNext(); length++; } return length; } // 向单向链表中插入新节点 public SinglyListNode insertInLinked(SinglyListNode nodeToInsert, int position) { if (headNode == null) { System.err.println(\"Error: the linked list is empty !\"); return nodeToInsert; } int size = getListLength(); if (position > size + 1 || position previousNode = headNode; while (count currentNode = previousNode.getNext();// 待插节点的后节点 nodeToInsert.setNext(currentNode); previousNode.setNext(nodeToInsert); } return headNode; } // 删除单向链表中的节点 public boolean deleteNodeFromLinkedList(/* ListNode headNode, */ int position) { int size = getListLength(); if (position > size || position currentNode = headNode.getNext(); headNode = currentNode; return true; // 删除中间或尾结点 } else { int count = 1; SinglyListNode previousNode = headNode.getNext(); while (count currentNode = previousNode.getNext(); // 待删节点 previousNode.setNext(currentNode.getNext()); currentNode = null; } return true; } // 遍历删除单向链表中的所有节点 public boolean destroyLinkedList(/* ListNode headNode */) { if (headNode == null) { System.err.println(\"异常 : 单向链表为空 !\"); return false; } System.out.print(\"遍历删除单向链表中的所有节点 : \"); while (headNode != null) { System.out.print(headNode.getData() + \" , \"); headNode = headNode.getNext(); } System.out.println(); return true; } // 遍历输出单向链表中的所有节点 public boolean traverseNode( /* ListNode headNode */) { if (headNode == null) { System.err.println(\"异常 : 单向链表为空 !\"); return false; } SinglyListNode currentNode = headNode; System.out.print(\"遍历输出单向链表中的所有节点 : \"); while (currentNode != null) { System.out.print(currentNode.getData() + \" , \"); currentNode = currentNode.getNext(); } System.out.println(); return true; } // 测试 public static void main(String[] args) { SinglyLinkedList list = new SinglyLinkedList(); // 初始化待插入链表的节点 SinglyListNode a = new SinglyListNode(); a.setData(\"A\"); SinglyListNode b = new SinglyListNode(); b.setData(\"B\"); SinglyListNode c = new SinglyListNode(); c.setData(\"C\"); // 向单向链表中添加新的节点 list.createLinkedList(); list.insertInLinked(a, 1); list.insertInLinked(b, 2); list.insertInLinked(c, 1); System.out.println(\"单向链表的长度为 : \" + list.getListLength()); System.out.println(\"单向链表的头节点为 : \" + list.getHeaderNode()); list.traverseNode(); //遍历输出单向链表中的所有节点 System.out.println(\"删除单向链表中的第一个节点 : \" + list.deleteNodeFromLinkedList(1)); list.traverseNode(); System.out.println(\"删除单向链表中的所有节点 : \" + list.destroyLinkedList()); System.out.println(\"单向链表的长度为 : \" + list.getListLength()); list.traverseNode(); //遍历输出单向链表中的所有节点 } } Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"LeetCod刷题之旅及题目解析/":{"url":"LeetCod刷题之旅及题目解析/","title":"LeetCode 刷题之旅","keywords":"","body":" 📝 LeetCode刷题之旅及题目解析 Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "},"LeetCod刷题之旅及题目解析/待更新.html":{"url":"LeetCod刷题之旅及题目解析/待更新.html","title":"待更新···","keywords":"","body":" ❌ 待更新· · · · · · Copyright © 黄宇辉 2020 all right reserved，powered by Gitbook笔记的最近一次更新时间为 : 2020-07-19 14:33:57 "}}